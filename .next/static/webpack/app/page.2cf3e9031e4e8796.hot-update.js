"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var _swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @swc/helpers/_/_tagged_template_literal */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_tagged_template_literal.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\nfunction _templateObject() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"views + 1\"\n    ]);\n    _templateObject = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject1() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"likes - 1\"\n    ]);\n    _templateObject1 = function() {\n        return data;\n    };\n    return data;\n}\nfunction _templateObject2() {\n    const data = (0,_swc_helpers_tagged_template_literal__WEBPACK_IMPORTED_MODULE_0__._)([\n        \"likes + 1\"\n    ]);\n    _templateObject2 = function() {\n        return data;\n    };\n    return data;\n}\n\n\nfunction useSupabaseData(user) {\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        try {\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            let userLikedSongs = new Set();\n            if (user) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n                if (likedData) {\n                    userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                    setLikedSongs(userLikedSongs);\n                }\n            }\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            setSongs(convertedSongs);\n            // Get last played song\n            if (user) {\n                const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n                if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                    const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                    if (lastSong) {\n                        setLastPlayedSong(lastSong);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Increment song views\n    const incrementViews = async (songId)=>{\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"songs\").update({\n                views: _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.sql(_templateObject())\n            }).eq(\"file_id\", parseInt(songId));\n            if (error) throw error;\n            // Update local state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        views: song.views + 1\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                views: song.views + 1\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error incrementing views:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove like\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes count in songs table\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"songs\").update({\n                    likes: _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.sql(_templateObject1())\n                }).eq(\"file_id\", songFileId);\n                if (updateError) throw updateError;\n                // Update local liked songs set\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n                // Update songs state immediately\n                setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                            ...song,\n                            isLiked: false,\n                            likes: Math.max(0, song.likes - 1)\n                        } : song));\n                // Update playlists state immediately\n                setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                            ...playlist,\n                            songs: playlist.songs.map((song)=>song.id === songId ? {\n                                    ...song,\n                                    isLiked: false,\n                                    likes: Math.max(0, song.likes - 1)\n                                } : song)\n                        })));\n                // Update last played song if it's the same song\n                setLastPlayedSong((prev)=>prev && prev.id === songId ? {\n                        ...prev,\n                        isLiked: false,\n                        likes: Math.max(0, prev.likes - 1)\n                    } : prev);\n            } else {\n                // Add like\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes count in songs table\n                const { error: updateError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"songs\").update({\n                    likes: _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.sql(_templateObject2())\n                }).eq(\"file_id\", songFileId);\n                if (updateError) throw updateError;\n                // Update local liked songs set\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n                // Update songs state immediately\n                setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                            ...song,\n                            isLiked: true,\n                            likes: song.likes + 1\n                        } : song));\n                // Update playlists state immediately\n                setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                            ...playlist,\n                            songs: playlist.songs.map((song)=>song.id === songId ? {\n                                    ...song,\n                                    isLiked: true,\n                                    likes: song.likes + 1\n                                } : song)\n                        })));\n                // Update last played song if it's the same song\n                setLastPlayedSong((prev)=>prev && prev.id === songId ? {\n                        ...prev,\n                        isLiked: true,\n                        likes: prev.likes + 1\n                    } : prev);\n            }\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const now = new Date();\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"history\").upsert({\n                        user_id: user.id,\n                        song_id: parseInt(currentSongRef.current),\n                        last_date: now.toISOString().split(\"T\")[0],\n                        last_time: now.toTimeString().split(\" \")[0],\n                        minutes_listened: Math.round(minutesListened * 100) / 100 // Round to 2 decimal places\n                    }, {\n                        onConflict: \"user_id,song_id,last_date\",\n                        ignoreDuplicates: false\n                    });\n                    if (error) throw error;\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        // Increment views for the new song\n        await incrementViews(songId);\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const now = new Date();\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_2__.supabase.from(\"history\").upsert({\n                        user_id: user.id,\n                        song_id: parseInt(currentSongRef.current),\n                        last_date: now.toISOString().split(\"T\")[0],\n                        last_time: now.toTimeString().split(\" \")[0],\n                        minutes_listened: Math.round(minutesListened * 100) / 100\n                    }, {\n                        onConflict: \"user_id,song_id,last_date\",\n                        ignoreDuplicates: false\n                    });\n                    if (error) throw error;\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    // Clear last played song\n    const clearLastPlayedSong = ()=>{\n        setLastPlayedSong(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            setLoading(true);\n            await Promise.all([\n                fetchSongs(),\n                fetchPlaylists()\n            ]);\n            setLoading(false);\n        };\n        if (user) {\n            loadData();\n        } else {\n            setLoading(false);\n        }\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        clearLastPlayedSong,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBbUQ7QUFFc0I7QUFHbEUsU0FBU0ksZ0JBQWdCQyxJQUFpQjtJQUMvQyxNQUFNLENBQUNDLE9BQU9DLFNBQVMsR0FBR1AsK0NBQVFBLENBQVMsRUFBRTtJQUM3QyxNQUFNLENBQUNRLFdBQVdDLGFBQWEsR0FBR1QsK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNVLFlBQVlDLGNBQWMsR0FBR1gsK0NBQVFBLENBQWMsSUFBSVk7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHZCwrQ0FBUUEsQ0FBYztJQUNsRSxNQUFNLENBQUNlLFNBQVNDLFdBQVcsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ2lCLHNCQUFzQkMsd0JBQXdCLEdBQUdsQiwrQ0FBUUEsQ0FBYztJQUM5RSxNQUFNbUIsaUJBQWlCakIsNkNBQU1BLENBQWdCO0lBRTdDLDBDQUEwQztJQUMxQyxNQUFNa0Isc0JBQXNCLFNBQUNDO1lBQXNCQywyRUFBbUI7ZUFBaUI7WUFDckZDLFNBQVNGLE9BQU9FLE9BQU87WUFDdkJDLFFBQVFILE9BQU9HLE1BQU07WUFDckJDLE1BQU1KLE9BQU9JLElBQUk7WUFDakJDLFFBQVFMLE9BQU9LLE1BQU07WUFDckJDLFVBQVVOLE9BQU9NLFFBQVE7WUFDekJDLE1BQU1QLE9BQU9PLElBQUk7WUFDakJDLE9BQU9SLE9BQU9RLEtBQUs7WUFDbkJDLE9BQU9ULE9BQU9TLEtBQUs7WUFDbkJDLElBQUlWLE9BQU9FLE9BQU8sQ0FBQ1MsUUFBUTtZQUMzQkMsT0FBTyxvQ0FBa0VaLE9BQTlCQSxPQUFPRyxNQUFNLEVBQUMsa0JBQThCLE9BQWRILE9BQU9HLE1BQU0sRUFBQztZQUN2RkY7UUFDRjs7SUFFQSxrQkFBa0I7SUFDbEIsTUFBTVksYUFBYTtRQUNqQixJ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RjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cz9hYmZjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJ0BzdXBhYmFzZS9zdXBhYmFzZS1qcydcbmltcG9ydCB7IHN1cGFiYXNlLCBEYXRhYmFzZVNvbmcsIERhdGFiYXNlUGxheWxpc3QgfSBmcm9tICdAL2xpYi9zdXBhYmFzZSdcbmltcG9ydCB7IFNvbmcsIFBsYXlsaXN0IH0gZnJvbSAnQC90eXBlcydcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1cGFiYXNlRGF0YSh1c2VyOiBVc2VyIHwgbnVsbCkge1xuICBjb25zdCBbc29uZ3MsIHNldFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIGNvbnN0IFtwbGF5bGlzdHMsIHNldFBsYXlsaXN0c10gPSB1c2VTdGF0ZTxQbGF5bGlzdFtdPihbXSlcbiAgY29uc3QgW2xpa2VkU29uZ3MsIHNldExpa2VkU29uZ3NdID0gdXNlU3RhdGU8U2V0PG51bWJlcj4+KG5ldyBTZXQoKSlcbiAgY29uc3QgW2xhc3RQbGF5ZWRTb25nLCBzZXRMYXN0UGxheWVkU29uZ10gPSB1c2VTdGF0ZTxTb25nIHwgbnVsbD4obnVsbClcbiAgY29uc3QgW2xvYWRpbmcsIHNldExvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSlcbiAgY29uc3QgW2N1cnJlbnRTb25nU3RhcnRUaW1lLCBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbClcbiAgY29uc3QgY3VycmVudFNvbmdSZWYgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbClcblxuICAvLyBDb252ZXJ0IGRhdGFiYXNlIHNvbmcgdG8gVUkgc29uZyBmb3JtYXRcbiAgY29uc3QgY29udmVydERhdGFiYXNlU29uZyA9IChkYlNvbmc6IERhdGFiYXNlU29uZywgaXNMaWtlZDogYm9vbGVhbiA9IGZhbHNlKTogU29uZyA9PiAoe1xuICAgIGZpbGVfaWQ6IGRiU29uZy5maWxlX2lkLFxuICAgIGltZ19pZDogZGJTb25nLmltZ19pZCxcbiAgICBuYW1lOiBkYlNvbmcubmFtZSxcbiAgICBhcnRpc3Q6IGRiU29uZy5hcnRpc3QsXG4gICAgbGFuZ3VhZ2U6IGRiU29uZy5sYW5ndWFnZSxcbiAgICB0YWdzOiBkYlNvbmcudGFncyxcbiAgICB2aWV3czogZGJTb25nLnZpZXdzLFxuICAgIGxpa2VzOiBkYlNvbmcubGlrZXMsXG4gICAgaWQ6IGRiU29uZy5maWxlX2lkLnRvU3RyaW5nKCksXG4gICAgaW1hZ2U6IGBodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8ke2RiU29uZy5pbWdfaWR9L3BleGVscy1waG90by0ke2RiU29uZy5pbWdfaWR9LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMGAsXG4gICAgaXNMaWtlZFxuICB9KVxuXG4gIC8vIEZldGNoIGFsbCBzb25nc1xuICBjb25zdCBmZXRjaFNvbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHNvbmdzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgIC5zZWxlY3QoJyonKVxuICAgICAgICAub3JkZXIoJ3ZpZXdzJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIFxuICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgY29uc3QgeyBkYXRhOiBsaWtlZERhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuICAgICAgICBcbiAgICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldChsaWtlZERhdGEubWFwKGl0ZW0gPT4gaXRlbS5zb25nX2lkKSlcbiAgICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFNvbmdzID0gc29uZ3NEYXRhPy5tYXAoc29uZyA9PiBcbiAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSlcbiAgICAgICkgfHwgW11cblxuICAgICAgc2V0U29uZ3MoY29udmVydGVkU29uZ3MpXG5cbiAgICAgIC8vIEdldCBsYXN0IHBsYXllZCBzb25nXG4gICAgICBpZiAodXNlcikge1xuICAgICAgICBjb25zdCB7IGRhdGE6IHVzZXJEYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuICAgICAgICAgIC5zaW5nbGUoKVxuXG4gICAgICAgIGlmICh1c2VyRGF0YT8ubGFzdF9zb25nX2ZpbGVfaWQpIHtcbiAgICAgICAgICBjb25zdCBsYXN0U29uZyA9IGNvbnZlcnRlZFNvbmdzLmZpbmQoc29uZyA9PiBzb25nLmZpbGVfaWQgPT09IHVzZXJEYXRhLmxhc3Rfc29uZ19maWxlX2lkKVxuICAgICAgICAgIGlmIChsYXN0U29uZykge1xuICAgICAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobGFzdFNvbmcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHNvbmdzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEZldGNoIHVzZXIgcGxheWxpc3RzXG4gIGNvbnN0IGZldGNoUGxheWxpc3RzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0UGxheWxpc3RzKFtdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogcGxheWxpc3RzRGF0YSwgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuc2VsZWN0KGBcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHBsYXlsaXN0X3NvbmdzIChcbiAgICAgICAgICAgIHNvbmdzICgqKVxuICAgICAgICAgIClcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBjb252ZXJ0ZWRQbGF5bGlzdHM6IFBsYXlsaXN0W10gPSBwbGF5bGlzdHNEYXRhPy5tYXAocGxheWxpc3QgPT4ge1xuICAgICAgICBjb25zdCBwbGF5bGlzdFNvbmdzID0gcGxheWxpc3QucGxheWxpc3Rfc29uZ3M/Lm1hcCgocHM6IGFueSkgPT4gXG4gICAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhwcy5zb25ncywgbGlrZWRTb25ncy5oYXMocHMuc29uZ3MuZmlsZV9pZCkpXG4gICAgICAgICkgfHwgW11cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkOiBwbGF5bGlzdC5pZC50b1N0cmluZygpLFxuICAgICAgICAgIG5hbWU6IHBsYXlsaXN0Lm5hbWUsXG4gICAgICAgICAgc29uZ0NvdW50OiBwbGF5bGlzdFNvbmdzLmxlbmd0aCxcbiAgICAgICAgICBpbWFnZTogcGxheWxpc3RTb25nc1swXT8uaW1hZ2UgfHwgJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgICBzb25nczogcGxheWxpc3RTb25nc1xuICAgICAgICB9XG4gICAgICB9KSB8fCBbXVxuXG4gICAgICBzZXRQbGF5bGlzdHMoY29udmVydGVkUGxheWxpc3RzKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwbGF5bGlzdHM6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gSW5jcmVtZW50IHNvbmcgdmlld3NcbiAgY29uc3QgaW5jcmVtZW50Vmlld3MgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnVwZGF0ZSh7IHZpZXdzOiBzdXBhYmFzZS5zcWxgdmlld3MgKyAxYCB9KVxuICAgICAgICAuZXEoJ2ZpbGVfaWQnLCBwYXJzZUludChzb25nSWQpKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgc2V0U29uZ3MocHJldlNvbmdzID0+IFxuICAgICAgICBwcmV2U29uZ3MubWFwKHNvbmcgPT4gXG4gICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkID8geyAuLi5zb25nLCB2aWV3czogc29uZy52aWV3cyArIDEgfSA6IHNvbmdcbiAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlXG4gICAgICBzZXRQbGF5bGlzdHMocHJldlBsYXlsaXN0cyA9PlxuICAgICAgICBwcmV2UGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiAoe1xuICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdC5zb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkID8geyAuLi5zb25nLCB2aWV3czogc29uZy52aWV3cyArIDEgfSA6IHNvbmdcbiAgICAgICAgICApXG4gICAgICAgIH0pKVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbmNyZW1lbnRpbmcgdmlld3M6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVG9nZ2xlIGxpa2Ugc29uZ1xuICBjb25zdCB0b2dnbGVMaWtlID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpXG4gICAgY29uc3QgaXNDdXJyZW50bHlMaWtlZCA9IGxpa2VkU29uZ3MuaGFzKHNvbmdGaWxlSWQpXG5cbiAgICB0cnkge1xuICAgICAgaWYgKGlzQ3VycmVudGx5TGlrZWQpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGxpa2VcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5kZWxldGUoKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgICAgLmVxKCdzb25nX2lkJywgc29uZ0ZpbGVJZClcblxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgLy8gRGVjcmVtZW50IGxpa2VzIGNvdW50IGluIHNvbmdzIHRhYmxlXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnVwZGF0ZSh7IGxpa2VzOiBzdXBhYmFzZS5zcWxgbGlrZXMgLSAxYCB9KVxuICAgICAgICAgIC5lcSgnZmlsZV9pZCcsIHNvbmdGaWxlSWQpXG5cbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvclxuXG4gICAgICAgIC8vIFVwZGF0ZSBsb2NhbCBsaWtlZCBzb25ncyBzZXRcbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0KHByZXYpXG4gICAgICAgICAgbmV3U2V0LmRlbGV0ZShzb25nRmlsZUlkKVxuICAgICAgICAgIHJldHVybiBuZXdTZXRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBVcGRhdGUgc29uZ3Mgc3RhdGUgaW1tZWRpYXRlbHlcbiAgICAgICAgc2V0U29uZ3MocHJldlNvbmdzID0+IFxuICAgICAgICAgIHByZXZTb25ncy5tYXAoc29uZyA9PiBcbiAgICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZCA/IHsgLi4uc29uZywgaXNMaWtlZDogZmFsc2UsIGxpa2VzOiBNYXRoLm1heCgwLCBzb25nLmxpa2VzIC0gMSkgfSA6IHNvbmdcbiAgICAgICAgICApXG4gICAgICAgIClcblxuICAgICAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlIGltbWVkaWF0ZWx5XG4gICAgICAgIHNldFBsYXlsaXN0cyhwcmV2UGxheWxpc3RzID0+XG4gICAgICAgICAgcHJldlBsYXlsaXN0cy5tYXAocGxheWxpc3QgPT4gKHtcbiAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgc29uZ3M6IHBsYXlsaXN0LnNvbmdzLm1hcChzb25nID0+XG4gICAgICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZCA/IHsgLi4uc29uZywgaXNMaWtlZDogZmFsc2UsIGxpa2VzOiBNYXRoLm1heCgwLCBzb25nLmxpa2VzIC0gMSkgfSA6IHNvbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KSlcbiAgICAgICAgKVxuXG4gICAgICAgIC8vIFVwZGF0ZSBsYXN0IHBsYXllZCBzb25nIGlmIGl0J3MgdGhlIHNhbWUgc29uZ1xuICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhwcmV2ID0+IFxuICAgICAgICAgIHByZXYgJiYgcHJldi5pZCA9PT0gc29uZ0lkIFxuICAgICAgICAgICAgPyB7IC4uLnByZXYsIGlzTGlrZWQ6IGZhbHNlLCBsaWtlczogTWF0aC5tYXgoMCwgcHJldi5saWtlcyAtIDEpIH1cbiAgICAgICAgICAgIDogcHJldlxuICAgICAgICApXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFkZCBsaWtlXG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICBzb25nX2lkOiBzb25nRmlsZUlkXG4gICAgICAgICAgfSlcblxuICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGxpa2VzIGNvdW50IGluIHNvbmdzIHRhYmxlXG4gICAgICAgIGNvbnN0IHsgZXJyb3I6IHVwZGF0ZUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnVwZGF0ZSh7IGxpa2VzOiBzdXBhYmFzZS5zcWxgbGlrZXMgKyAxYCB9KVxuICAgICAgICAgIC5lcSgnZmlsZV9pZCcsIHNvbmdGaWxlSWQpXG5cbiAgICAgICAgaWYgKHVwZGF0ZUVycm9yKSB0aHJvdyB1cGRhdGVFcnJvclxuXG4gICAgICAgIC8vIFVwZGF0ZSBsb2NhbCBsaWtlZCBzb25ncyBzZXRcbiAgICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IG5ldyBTZXQocHJldikuYWRkKHNvbmdGaWxlSWQpKVxuXG4gICAgICAgIC8vIFVwZGF0ZSBzb25ncyBzdGF0ZSBpbW1lZGlhdGVseVxuICAgICAgICBzZXRTb25ncyhwcmV2U29uZ3MgPT4gXG4gICAgICAgICAgcHJldlNvbmdzLm1hcChzb25nID0+IFxuICAgICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkID8geyAuLi5zb25nLCBpc0xpa2VkOiB0cnVlLCBsaWtlczogc29uZy5saWtlcyArIDEgfSA6IHNvbmdcbiAgICAgICAgICApXG4gICAgICAgIClcblxuICAgICAgICAvLyBVcGRhdGUgcGxheWxpc3RzIHN0YXRlIGltbWVkaWF0ZWx5XG4gICAgICAgIHNldFBsYXlsaXN0cyhwcmV2UGxheWxpc3RzID0+XG4gICAgICAgICAgcHJldlBsYXlsaXN0cy5tYXAocGxheWxpc3QgPT4gKHtcbiAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgc29uZ3M6IHBsYXlsaXN0LnNvbmdzLm1hcChzb25nID0+XG4gICAgICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZCA/IHsgLi4uc29uZywgaXNMaWtlZDogdHJ1ZSwgbGlrZXM6IHNvbmcubGlrZXMgKyAxIH0gOiBzb25nXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSkpXG4gICAgICAgIClcblxuICAgICAgICAvLyBVcGRhdGUgbGFzdCBwbGF5ZWQgc29uZyBpZiBpdCdzIHRoZSBzYW1lIHNvbmdcbiAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcocHJldiA9PiBcbiAgICAgICAgICBwcmV2ICYmIHByZXYuaWQgPT09IHNvbmdJZCBcbiAgICAgICAgICAgID8geyAuLi5wcmV2LCBpc0xpa2VkOiB0cnVlLCBsaWtlczogcHJldi5saWtlcyArIDEgfVxuICAgICAgICAgICAgOiBwcmV2XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdG9nZ2xpbmcgbGlrZTonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBDcmVhdGUgcGxheWxpc3RcbiAgY29uc3QgY3JlYXRlUGxheWxpc3QgPSBhc3luYyAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBuZXdQbGF5bGlzdDogUGxheWxpc3QgPSB7XG4gICAgICAgIGlkOiBkYXRhLmlkLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgc29uZ0NvdW50OiAwLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgc29uZ3M6IFtdXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdQbGF5bGlzdF0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBwbGF5bGlzdFxuICBjb25zdCBkZWxldGVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IHByZXYuZmlsdGVyKHBsYXlsaXN0ID0+IHBsYXlsaXN0LmlkICE9PSBwbGF5bGlzdElkKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVuYW1lIHBsYXlsaXN0XG4gIGNvbnN0IHJlbmFtZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnVwZGF0ZSh7IG5hbWU6IG5ld05hbWUgfSlcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiBcbiAgICAgICAgICBwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCBcbiAgICAgICAgICAgID8geyAuLi5wbGF5bGlzdCwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICA6IHBsYXlsaXN0XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuYW1pbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHNvbmcgdG8gcGxheWxpc3RcbiAgY29uc3QgYWRkU29uZ1RvUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBzb25nOiBTb25nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwbGF5bGlzdF9pZDogcGFyc2VJbnQocGxheWxpc3RJZCksXG4gICAgICAgICAgc29uZ19pZDogc29uZy5maWxlX2lkXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgICBpZiAocGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvbmdFeGlzdHMgPSBwbGF5bGlzdC5zb25ncy5zb21lKHMgPT4gcy5pZCA9PT0gc29uZy5pZClcbiAgICAgICAgICAgIGlmICghc29uZ0V4aXN0cykge1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBbLi4ucGxheWxpc3Quc29uZ3MsIHNvbmddXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgICBzb25nQ291bnQ6IHVwZGF0ZWRTb25ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgcGxheWxpc3QuaW1hZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNvbmcgdG8gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHNvbmcgZnJvbSBwbGF5bGlzdFxuICBjb25zdCByZW1vdmVTb25nRnJvbVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdF9zb25ncycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ3BsYXlsaXN0X2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgnc29uZ19pZCcsIHBhcnNlSW50KHNvbmdJZCkpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgICBpZiAocGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb25ncyA9IHBsYXlsaXN0LnNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaWQgIT09IHNvbmdJZClcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICBzb25nczogdXBkYXRlZFNvbmdzLFxuICAgICAgICAgICAgICBzb25nQ291bnQ6IHVwZGF0ZWRTb25ncy5sZW5ndGgsXG4gICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNvbmcgZnJvbSBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgbGFzdCBzb25nIGluIHVzZXIgcHJvZmlsZVxuICBjb25zdCB1cGRhdGVMYXN0U29uZyA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnVwZGF0ZSh7IGxhc3Rfc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGxhc3Qgc29uZzonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZWNvcmQgbGlzdGVuaW5nIGhpc3Rvcnkgd2l0aCBwcm9wZXIgdGltZSB0cmFja2luZ1xuICBjb25zdCByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5ID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIC8vIElmIHRoZXJlJ3MgYSBwcmV2aW91cyBzb25nIHBsYXlpbmcsIHJlY29yZCBpdHMgbGlzdGVuaW5nIHRpbWVcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSkge1xuICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKClcbiAgICAgIGNvbnN0IG1pbnV0ZXNMaXN0ZW5lZCA9IChlbmRUaW1lLmdldFRpbWUoKSAtIGN1cnJlbnRTb25nU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKVxuICAgICAgXG4gICAgICBpZiAobWludXRlc0xpc3RlbmVkID4gMC4xKSB7IC8vIE9ubHkgcmVjb3JkIGlmIGxpc3RlbmVkIGZvciBtb3JlIHRoYW4gNiBzZWNvbmRzXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgICAgICAudXBzZXJ0KHtcbiAgICAgICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgc29uZ19pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICAgICAgICAgIGxhc3RfZGF0ZTogbm93LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgbGFzdF90aW1lOiBub3cudG9UaW1lU3RyaW5nKCkuc3BsaXQoJyAnKVswXSxcbiAgICAgICAgICAgICAgbWludXRlc19saXN0ZW5lZDogTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwIC8vIFJvdW5kIHRvIDIgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgb25Db25mbGljdDogJ3VzZXJfaWQsc29uZ19pZCxsYXN0X2RhdGUnLFxuICAgICAgICAgICAgICBpZ25vcmVEdXBsaWNhdGVzOiBmYWxzZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgcHJldmlvdXMgc29uZyBoaXN0b3J5OicsIGVycm9yKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IG5ldyBzb25nIGFzIGN1cnJlbnRcbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gc29uZ0lkXG4gICAgc2V0Q3VycmVudFNvbmdTdGFydFRpbWUobmV3IERhdGUoKSlcbiAgICBcbiAgICAvLyBVcGRhdGUgbGFzdCBzb25nIGluIHVzZXIgcHJvZmlsZVxuICAgIGF3YWl0IHVwZGF0ZUxhc3RTb25nKHNvbmdJZClcblxuICAgIC8vIEluY3JlbWVudCB2aWV3cyBmb3IgdGhlIG5ldyBzb25nXG4gICAgYXdhaXQgaW5jcmVtZW50Vmlld3Moc29uZ0lkKVxuICB9XG5cbiAgLy8gU3RvcCBjdXJyZW50IHNvbmcgdHJhY2tpbmcgKHdoZW4gcGxheWVyIGlzIGNsb3NlZClcbiAgY29uc3Qgc3RvcEN1cnJlbnRTb25nVHJhY2tpbmcgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgJiYgY3VycmVudFNvbmdTdGFydFRpbWUgJiYgdXNlcikge1xuICAgICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKClcbiAgICAgIGNvbnN0IG1pbnV0ZXNMaXN0ZW5lZCA9IChlbmRUaW1lLmdldFRpbWUoKSAtIGN1cnJlbnRTb25nU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKVxuICAgICAgXG4gICAgICBpZiAobWludXRlc0xpc3RlbmVkID4gMC4xKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKVxuICAgICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgICAgICAudXBzZXJ0KHtcbiAgICAgICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICAgICAgc29uZ19pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICAgICAgICAgIGxhc3RfZGF0ZTogbm93LnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXSxcbiAgICAgICAgICAgICAgbGFzdF90aW1lOiBub3cudG9UaW1lU3RyaW5nKCkuc3BsaXQoJyAnKVswXSxcbiAgICAgICAgICAgICAgbWludXRlc19saXN0ZW5lZDogTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIG9uQ29uZmxpY3Q6ICd1c2VyX2lkLHNvbmdfaWQsbGFzdF9kYXRlJyxcbiAgICAgICAgICAgICAgaWdub3JlRHVwbGljYXRlczogZmFsc2VcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVjb3JkaW5nIGZpbmFsIHNvbmcgaGlzdG9yeTonLCBlcnJvcilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgPSBudWxsXG4gICAgc2V0Q3VycmVudFNvbmdTdGFydFRpbWUobnVsbClcbiAgfVxuXG4gIC8vIENsZWFyIGxhc3QgcGxheWVkIHNvbmdcbiAgY29uc3QgY2xlYXJMYXN0UGxheWVkU29uZyA9ICgpID0+IHtcbiAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaFNvbmdzKCksIGZldGNoUGxheWxpc3RzKCldKVxuICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICB9XG5cbiAgICBpZiAodXNlcikge1xuICAgICAgbG9hZERhdGEoKVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW3VzZXJdKVxuXG4gIHJldHVybiB7XG4gICAgc29uZ3MsXG4gICAgcGxheWxpc3RzLFxuICAgIGxpa2VkU29uZ3M6IHNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaXNMaWtlZCksXG4gICAgbGFzdFBsYXllZFNvbmcsXG4gICAgbG9hZGluZyxcbiAgICB0b2dnbGVMaWtlLFxuICAgIGNyZWF0ZVBsYXlsaXN0LFxuICAgIGRlbGV0ZVBsYXlsaXN0LFxuICAgIHJlbmFtZVBsYXlsaXN0LFxuICAgIGFkZFNvbmdUb1BsYXlsaXN0LFxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXG4gICAgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSxcbiAgICBzdG9wQ3VycmVudFNvbmdUcmFja2luZyxcbiAgICBjbGVhckxhc3RQbGF5ZWRTb25nLFxuICAgIHJlZnJlc2hEYXRhOiAoKSA9PiB7XG4gICAgICBmZXRjaFNvbmdzKClcbiAgICAgIGZldGNoUGxheWxpc3RzKClcbiAgICB9XG4gIH1cbn0iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJzdXBhYmFzZSIsInVzZVN1cGFiYXNlRGF0YSIsInVzZXIiLCJzb25ncyIsInNldFNvbmdzIiwicGxheWxpc3RzIiwic2V0UGxheWxpc3RzIiwibGlrZWRTb25ncyIsInNldExpa2VkU29uZ3MiLCJTZXQiLCJsYXN0UGxheWVkU29uZyIsInNldExhc3RQbGF5ZWRTb25nIiwibG9hZGluZyIsInNldExvYWRpbmciLCJjdXJyZW50U29uZ1N0YXJ0VGltZSIsInNldEN1cnJlbnRTb25nU3RhcnRUaW1lIiwiY3VycmVudFNvbmdSZWYiLCJjb252ZXJ0RGF0YWJhc2VTb25nIiwiZGJTb25nIiwiaXNMaWtlZCIsImZpbGVfaWQiLCJpbWdfaWQiLCJuYW1lIiwiYXJ0aXN0IiwibGFuZ3VhZ2UiLCJ0YWdzIiwidmlld3MiLCJsaWtlcyIsImlkIiwidG9TdHJpbmciLCJpbWFnZSIsImZldGNoU29uZ3MiLCJkYXRhIiwic29uZ3NEYXRhIiwiZXJyb3IiLCJmcm9tIiwic2VsZWN0Iiwib3JkZXIiLCJhc2NlbmRpbmciLCJ1c2VyTGlrZWRTb25ncyIsImxpa2VkRGF0YSIsImVxIiwibWFwIiwiaXRlbSIsInNvbmdfaWQiLCJjb252ZXJ0ZWRTb25ncyIsInNvbmciLCJoYXMiLCJ1c2VyRGF0YSIsInNpbmdsZSIsImxhc3Rfc29uZ19maWxlX2lkIiwibGFzdFNvbmciLCJmaW5kIiwiY29uc29sZSIsImZldGNoUGxheWxpc3RzIiwicGxheWxpc3RzRGF0YSIsImNvbnZlcnRlZFBsYXlsaXN0cyIsInBsYXlsaXN0IiwicGxheWxpc3RTb25ncyIsInBsYXlsaXN0X3NvbmdzIiwicHMiLCJzb25nQ291bnQiLCJsZW5ndGgiLCJpbmNyZW1lbnRWaWV3cyIsInNvbmdJZCIsInVwZGF0ZSIsInNxbCIsInBhcnNlSW50IiwicHJldlNvbmdzIiwicHJldlBsYXlsaXN0cyIsInRvZ2dsZUxpa2UiLCJzb25nRmlsZUlkIiwiaXNDdXJyZW50bHlMaWtlZCIsImRlbGV0ZSIsInVwZGF0ZUVycm9yIiwicHJldiIsIm5ld1NldCIsIk1hdGgiLCJtYXgiLCJpbnNlcnQiLCJ1c2VyX2lkIiwiYWRkIiwiY3JlYXRlUGxheWxpc3QiLCJuZXdQbGF5bGlzdCIsImRlbGV0ZVBsYXlsaXN0IiwicGxheWxpc3RJZCIsImZpbHRlciIsInJlbmFtZVBsYXlsaXN0IiwibmV3TmFtZSIsImFkZFNvbmdUb1BsYXlsaXN0IiwicGxheWxpc3RfaWQiLCJzb25nRXhpc3RzIiwic29tZSIsInMiLCJ1cGRhdGVkU29uZ3MiLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwidXBkYXRlTGFzdFNvbmciLCJyZWNvcmRMaXN0ZW5pbmdIaXN0b3J5IiwiY3VycmVudCIsImVuZFRpbWUiLCJEYXRlIiwibWludXRlc0xpc3RlbmVkIiwiZ2V0VGltZSIsIm5vdyIsInVwc2VydCIsImxhc3RfZGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJsYXN0X3RpbWUiLCJ0b1RpbWVTdHJpbmciLCJtaW51dGVzX2xpc3RlbmVkIiwicm91bmQiLCJvbkNvbmZsaWN0IiwiaWdub3JlRHVwbGljYXRlcyIsInN0b3BDdXJyZW50U29uZ1RyYWNraW5nIiwiY2xlYXJMYXN0UGxheWVkU29uZyIsImxvYWREYXRhIiwiUHJvbWlzZSIsImFsbCIsInJlZnJlc2hEYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});